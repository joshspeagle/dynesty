#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
A set of simple plotting functions to visualize results from
dynesty runs.

This code/API draws heavily upon (and in many places is almost an
outright copy of) Daniel Foreman-Mackey's `corner.py`
<http://corner.readthedocs.io>.

"""

from __future__ import (print_function, division)
try:
    from builtins import range
except ImportError:
    from __builtin__ import range

import logging
import types
import numpy as np
import matplotlib.pyplot as pl
from matplotlib.ticker import MaxNLocator, NullLocator
from matplotlib.colors import LinearSegmentedColormap, colorConverter
from matplotlib.ticker import ScalarFormatter

try:
    from scipy.ndimage import gaussian_filter as norm_kde
except ImportError:
    norm_kde = None

__all__ = ["runplot", "traceplot", "proposal", "cornerplot",
           "cornerpoints", "cornerprop"]


def runplot(results, bounds=None, color='blue', plot_kwargs=None,
            label_kwargs=None, lnz_error=True, lnz_truth=None,
            truth_color='red', truth_kwargs=None, max_x_ticks=8,
            max_y_ticks=3, use_math_text=True, mark_final_live=True,
            fig=None):
    """
    Plot effective iteration, ln(likelihood), ln(weight), and ln(evidence)
    as a function of prior volume.


    Parameters
    ----------
    results : `Results` dictionary instance
        A results instance output by `dynesty` (or generated by the user).

    bounds : iterable with shape (4,), optional
        A list where each element is either a length 2 tuple containing
        lower and upper bounds or a float in range (0., 1.] giving the
        fraction below the maximum. If a fraction is provided,
        the bounds are chosen to be equal-tailed. An example would be
        [(0., 10.), 0.001, 0.2, (5., 6.)]. Default is `(0., 1.05*max(data))`.
        **Note that these values will be overriden if the 3-sigma
        errors on the evidence exceed the provided/computed bounds unless
        `lnz_err` is set to *False*.**

    color : str or iterable with shape (4,), optional
        A `~matplotlib` style color (either a single color or a different
        value for each subplot) used when plotting the lines in each subplot.
        Default is 'blue'.

    plot_kwargs : dict, optional
        Extra keyword arguments that will be passed to `plot`.

    label_kwargs : dict, optional
        Extra keyword arguments that will be sent to the `set_xlabel` and
        `set_ylabel` methods.

    lnz_error : bool, optional
        Whether to plot the 1, 2, and 3-sigma approximate error bars
        derived from the central limit theorem approximation over the course
        of the run. Default is *True*.

    lnz_truth : float, optional
        A reference value for the evidence that will be overplotted on the
        evidence subplot.

    truth_color : str or iterable with shape (ndim,), optional
        A `~matplotlib` style color used when plotting `lnz_truth`.
        Default is 'red'.

    truth_kwargs : dict, optional
        Extra keyword arguments that will be used for plotting `lnz_truths`.

    max_x_ticks : int, optional
        Maximum number of ticks allowed for the x axis. Default is *8*.

    max_y_ticks : int, optional
        Maximum number of ticks allowed for the y axis. Default is *4*.

    use_math_text : bool, optional
        Whether the axis tick labels for very large/small exponents should be
        displayed as powers of 10 rather than using `e`. Default is *False*.

    mark_final_live : bool, optional
        Whether to indicate the final addition of recycled live points
        (if they were added to the resulting samples) using
        a dashed vertical line. Default is *True*.

    fig : `~matplotlib.Figure`, optional
        If provided, overplot the run onto the provided figure object.
        Otherwise, by default an internal figure is generated.


    Returns
    -------
    traceplot : `~matplotlib.Figure`
        Output trace plot.

    """

    if label_kwargs is None:
        label_kwargs = dict()
    if plot_kwargs is None:
        plot_kwargs = dict()
    if truth_kwargs is None:
        truth_kwargs = dict()

    # Extract results.
    niter = results['niter']  # number of iterations
    nlive = results['nlive']  # number of live points
    logvol = results['logvol']  # ln(prior volume)
    logl = results['logl']  # ln(likelihood)
    logwt = results['logwt']  # ln(importance weight)
    logz = results['logz']  # ln(evidence)
    logzerr = results['logzerr']  # error in ln(evidence)
    nsamps = len(logwt)  # number of samples

    try:
        nlive_dynamic = results['samples_n']
        mark_final_live = False
    except:
        pass

    # Check if the final set of live points were added to the results.
    it = np.arange(nsamps)
    if mark_final_live:
        if nsamps - niter == nlive:
            live_idx = niter
        else:
            raise ValueError("The number of iterations and samples differ "
                             "by an amount that isn't the number of final "
                             "live points.")

    # Determine plotting bounds for each subplot.
    data = [it, np.exp(logl), np.exp(logwt), np.exp(logz)]
    if bounds is None:
        bounds = [(0., 1.05 * max(d)) for d in data]
    bounds = list(bounds)
    if len(bounds) != 4:
        raise ValueError("More bounds than subplots!")
    for i, _ in enumerate(bounds):
        try:
            ymin, ymax = bounds[i]
        except:
            bounds[i] = (max(data[i]) * bounds[i], max(data[i]))
    if lnz_error:
        zbounds = (min(max(np.exp(logz - 3.*logzerr)), bounds[3][0]),
                   max(1.05 * max(np.exp(logz + 3.*logzerr)), bounds[3][1]))
        bounds[3] = zbounds

    # Setting up default plot layout.
    if fig is None:
        fig, axes = pl.subplots(4, 1, figsize=(16, 16))
        xbounds = [(0., -min(logvol)) for ax in axes]
        ybounds = bounds
    else:
        fig, axes = fig
        try:
            axes.reshape(4, 1)
        except:
            raise ValueError("Provided axes do not match the required shape "
                             "for plotting samples.")
        # If figure is provided, keep previous bounds if they were larger.
        xbounds = [ax.get_xlim() for ax in axes]
        ybounds = [ax.get_ylim() for ax in axes]

    # Set up bounds for plotting.
    [ax.set_xlim([min(0., xbounds[i][0]),
                  max(-min(logvol), xbounds[i][1])])
     for i in range(4)]
    [ax.set_ylim([min(bounds[i][0], ybounds[i][0]),
                  max(bounds[i][1], ybounds[i][1])])
     for i in range(4)]

    # Plotting.
    labels = ['Iteration', 'Likelihood', 'Weight', 'Evidence']
    for i, d in enumerate(data):

        # Establish axes.
        ax = axes[i]
        # Set color(s)/colormap(s).
        if isinstance(color, types.StringTypes):
            c = color
        else:
            c = color[i]
        # Setup axes.
        if max_x_ticks == 0:
            ax.xaxis.set_major_locator(NullLocator())
        else:
            ax.xaxis.set_major_locator(MaxNLocator(max_x_ticks))
        if max_y_ticks == 0:
            ax.yaxis.set_major_locator(NullLocator())
        else:
            ax.yaxis.set_major_locator(MaxNLocator(max_y_ticks))
        # Label axes.
        sf = ScalarFormatter(useMathText=use_math_text)
        ax.yaxis.set_major_formatter(sf)
        ax.set_xlabel(r"$-\ln X$", **label_kwargs)
        ax.set_ylabel(labels[i], **label_kwargs)
        # Plot run.
        ax.plot(-logvol, d, color=c, lw=5, alpha=0.7, **plot_kwargs)
        if i == 3 and lnz_error:
            [ax.fill_between(-logvol, np.exp(logz + s*logzerr),
                             np.exp(logz - s*logzerr), color=c, alpha=0.2)
             for s in range(1, 4)]
        # Mark addition of final live points.
        if mark_final_live:
            ax.axvline(-logvol[live_idx], color=c, ls="dashed",
                       **plot_kwargs)
            if i == 0:
                ax.axhline(live_idx, color=c, ls="dashed",
                           **plot_kwargs)
        # Add truth value(s).
        if i == 3 and lnz_truth is not None:
            ax.axhline(lnz_truth, color=truth_color, ls="solid",
                       **truth_kwargs)

    return fig, axes


def traceplot(results, bounds=None, quantiles=[0.16, 0.5, 0.84], smooth=0.02,
              post_color='blue', post_kwargs=None, trace_cmap='plasma',
              trace_color=None, trace_kwargs=None, max_n_ticks=5,
              use_math_text=False, labels=None, label_kwargs=None,
              show_titles=False, title_fmt=".2f", title_kwargs=None,
              truths=None, truth_color='red', truth_kwargs=None,
              verbose=False, fig=None):
    """
    Plot traces and marginalized posteriors for each parameter.


    Parameters
    ----------
    results : `Results` dictionary instance
        A results instance output by `dynesty` (or generated by the user).

    bounds : iterable with shape (ndim,), optional
        A list where each element is either a length 2 tuple containing
        lower and upper bounds or a float in range (0., 1.] giving the
        fraction of (weighted) samples to include. If a fraction is provided,
        the bounds are chosen to be equal-tailed. An example would be
        [(0., 10.), 0.95, (5., 6.)]. Default is *0.999999426697*
        (5-sigma credible interval).

    quantiles : iterable, optional
        A list of fractional quantiles to overplot on the 1-D marginalized
        posteriors as vertical dashed lines. Default is *[0.16, 0.5, 0.84]*
        (spanning the 68%/1-sigma credible interval).

    smooth : float or iterable with shape (ndim,), optional
        The standard deviation (either a single value or a different value for
        each subplot) for the Gaussian kernel used to smooth the 1-D
        marginalized posteriors, expressed as a fraction of the bounds.
        Default is *0.02* (2% smoothing). If an integer is provided instead,
        this will instead default to a simple (weighted) histogram with
        `bins=smooth`.

    post_color : str or iterable with shape (ndim,), optional
        A `~matplotlib` style color (either a single color or a different
        value for each subplot) used when plotting the histograms.
        Default is 'blue'.

    post_kwargs : dict, optional
        Extra keyword arguments that will be used for plotting the
        marginalized 1-D posteriors.

    trace_cmap : str or iterable with shape (ndim,), optional
        A `~matplotlib` style colormap (either a single colormap or a
        different colormap for each subplot) used when plotting the traces,
        where each point is colored according to its weight. Default is
        'plasma'.

    trace_color : str or iterable with shape (ndim,), optional
        A `~matplotlib` style color (either a single color or a
        different color for each subplot) used when plotting the traces.
        This overrides the `trace_cmap` option by giving all points
        the same color. Default is *None*.

    trace_kwargs : dict, optional
        Extra keyword arguments that will be used for plotting the traces.

    max_n_ticks : int, optional
        Maximum number of ticks allowed. Default is *5*.

    use_math_text : bool, optional
        Whether the axis tick labels for very large/small exponents should be
        displayed as powers of 10 rather than using `e`. Default is *False*.

    labels : iterable with shape (ndim,), optional
        A list of names for each parameter. If not provided, the default name
        used when plotting is `x_i`.

    label_kwargs : dict, optional
        Extra keyword arguments that will be sent to the `set_xlabel` and
        `set_ylabel` methods.

    show_titles : bool, optional
        Whether to display a title above each 1-D marginalized posterior
        showing the 0.5 quantile along with the upper/lower bounds associated
        with the 0.16 and 0.84 (68%/1-sigma credible interval) quantiles.
        Default is *True*.

    title_fmt : str, optional
        The format string for the quantiles provided in the title. Default is
        ".2f".

    title_kwargs : dict, optional
        Extra keyword arguments that will be sent to the `set_title` command.

    truths : iterable with shape (ndim,), optional
        A list of reference values that will be overplotted on the traces and
        marginalized 1-D posteriors as solid horizontal/vertical lines.
        Individual values can be exempt using `None`. Default is *None*.

    truth_color : str or iterable with shape (ndim,), optional
        A `~matplotlib` style color (either a single color or a different
        value for each subplot) used when plotting `truths`. Default is 'red'.

    truth_kwargs : dict, optional
        Extra keyword arguments that will be used for plotting the vertical
        and horizontal lines with `truths`.

    verbose : bool, optional
        Whether to print the values of the computed quantiles associated with
        each parameter. Default is *False*.

    fig : `~matplotlib.Figure`, optional
        If provided, overplot the traces and marginalized 1-D posteriors
        onto the provided figure object. Otherwise, by default an
        internal figure is generated.


    Returns
    -------
    traceplot : `~matplotlib.Figure`
        Output trace plot.

    """

    if title_kwargs is None:
        title_kwargs = dict()
    if label_kwargs is None:
        label_kwargs = dict()
    if trace_kwargs is None:
        trace_kwargs = dict()
    if post_kwargs is None:
        post_kwargs = dict()
    post_kwargs['alpha'] = post_kwargs.get('alpha', 0.6)
    if truth_kwargs is None:
        truth_kwargs = dict()

    # Extract weighted samples.
    samples = results['samples']
    logvol = results['logvol']
    try:
        weights = np.exp(results['logwt'])
    except:
        weights = results['weights']

    # Deal with 1D results. A number of extra catches are also here
    # in case users are trying to plot other results besides the `Results`
    # instance generated by `dynesty`.
    samples = np.atleast_1d(samples)
    if len(samples.shape) == 1:
        samples = np.atleast_2d(samples)
    else:
        assert len(samples.shape) == 2, "Samples must be 1- or 2-D."
        samples = samples.T
    assert samples.shape[0] <= samples.shape[1], "There are more " \
                                                 "dimensions than samples!"
    ndim, nsamps = samples.shape

    # Check weights.
    if weights.ndim != 1:
        raise ValueError("Weights must be 1-D.")
    if nsamps != weights.shape[0]:
        raise ValueError("The number of weights and samples disagree!")

    # Check ln(volume).
    if logvol.ndim != 1:
        raise ValueError("Ln(volume)'s must be 1-D.")
    if nsamps != logvol.shape[0]:
        raise ValueError("The number of ln(volume)'s and samples disagree!")

    # Determine plotting bounds for marginalized 1-D posteriors.
    if bounds is None:
        bounds = [0.999999426697 for i in range(ndim)]
    bounds = list(bounds)
    if len(bounds) != ndim:
        raise ValueError("Dimension mismatch between samples and bounds.")
    for i, _ in enumerate(bounds):
        try:
            xmin, xmax = bounds[i]
        except:
            q = [0.5 - 0.5 * bounds[i], 0.5 + 0.5 * bounds[i]]
            bounds[i] = _quantile(samples[i], q, weights=weights)

    # Setting up labels.
    if labels is None:
        labels = [r"$x_{0}$".format(i) for i in range(ndim)]

    # Setting up smoothing.
    if (isinstance(smooth, types.IntType) or isinstance(smooth,
                                                        types.FloatType)):
        smooth = [smooth for i in range(ndim)]

    # Setting up default plot layout.
    if fig is None:
        fig, axes = pl.subplots(ndim, 2, figsize=(12, 3*ndim))
    else:
        fig, axes = fig
        try:
            axes.reshape(ndim, 2)
        except:
            raise ValueError("Provided axes do not match the required shape "
                             "for plotting samples.")

    # Plotting.
    for i, x in enumerate(samples):

        # Plot trace.

        # Establish axes.
        if np.shape(samples)[0] == 1:
            ax = axes[1]
        else:
            ax = axes[i, 0]
        # Set color(s)/colormap(s).
        if trace_color is not None:
            if isinstance(trace_color, types.StringTypes):
                color = trace_color
            else:
                color = trace_color[i]
        else:
            color = weights
        if isinstance(trace_cmap, types.StringTypes):
            cmap = trace_cmap
        else:
            cmap = trace_cmap[i]
        # Setup axes.
        ax.set_xlim([0., -min(logvol)])
        ax.set_ylim([min(x), max(x)])
        if max_n_ticks == 0:
            ax.xaxis.set_major_locator(NullLocator())
            ax.yaxis.set_major_locator(NullLocator())
        else:
            ax.xaxis.set_major_locator(MaxNLocator(max_n_ticks))
            ax.yaxis.set_major_locator(MaxNLocator(max_n_ticks))
        # Label axes.
        sf = ScalarFormatter(useMathText=use_math_text)
        ax.yaxis.set_major_formatter(sf)
        ax.set_xlabel(r"$-\ln X$", **label_kwargs)
        ax.set_ylabel(labels[i], **label_kwargs)
        # Generate scatter plot.
        ax.scatter(-logvol, x, c=color, s=5, cmap=cmap,
                   **trace_kwargs)
        # Add truth value(s).
        if truths is not None and truths[i] is not None:
            try:
                [ax.axhline(t, color=truth_color, ls="solid",
                            **truth_kwargs) for t in truths[i]]
            except:
                ax.axhline(truths[i], color=truth_color, ls="solid",
                           **truth_kwargs)

        # Plot marginalized 1-D posterior.

        # Establish axes.
        if np.shape(samples)[0] == 1:
            ax = axes[0]
        else:
            ax = axes[i, 1]
        # Set color(s).
        if isinstance(post_color, types.StringTypes):
            color = post_color
        else:
            color = post_color[i]
        # Setup axes
        ax.set_xlim(bounds[i])
        if max_n_ticks == 0:
            ax.xaxis.set_major_locator(NullLocator())
            ax.yaxis.set_major_locator(NullLocator())
        else:
            ax.xaxis.set_major_locator(MaxNLocator(max_n_ticks))
            ax.yaxis.set_major_locator(NullLocator())
        # Label axes.
        sf = ScalarFormatter(useMathText=use_math_text)
        ax.xaxis.set_major_formatter(sf)
        if labels is not None:
            label = labels[i]
        else:
            label = r"$x_{0}$".format(i)
        ax.set_xlabel(label, **label_kwargs)
        # Generate distribution.
        s = smooth[i]
        if isinstance(s, types.IntType):
            # If `s` is an integer, plot a weighted histogram with
            # `s` bins within the provided bounds.
            n, b, _ = ax.hist(x, bins=s, weights=weights, color=color,
                              range=np.sort(bounds[i]), **post_kwargs)
            x0 = np.array(list(zip(b[:-1], b[1:]))).flatten()
            y0 = np.array(list(zip(n, n))).flatten()
        else:
            if norm_kde is None:
                raise ImportError("Please install scipy if you would like "
                                  "to use Gaussian smoothing.")
            # If `s` is a float, oversample the data relative to the
            # smoothing filter by a factor of 5, then use a Gaussian
            # filter to smooth the results.
            bins = int(round(5. / s))
            n, b = np.histogram(x, bins=bins, weights=weights,
                                range=np.sort(bounds[i]))
            n = norm_kde(n, 5.)
            x0 = 0.5 * (b[1:] + b[:-1])
            y0 = n
            ax.fill_between(x0, y0, color=color, **post_kwargs)
        ax.set_ylim([0., max(y0) * 1.05])
        # Plot quantiles.
        if quantiles is not None and len(quantiles) > 0:
            qs = _quantile(x, quantiles, weights=weights)
            for q in qs:
                ax.axvline(q, lw=2, ls="dashed", color=color)
            if verbose:
                print("Quantiles:")
                print(label, [blob for blob in zip(quantiles, qs)])
        # Add truth value(s).
        if truths is not None and truths[i] is not None:
            try:
                [ax.axvline(t, color=truth_color, ls="solid",
                            **truth_kwargs) for t in truths[i]]
            except:
                ax.axvline(truths[i], color=truth_color, ls="solid",
                           **truth_kwargs)
        # Set titles.
        if show_titles:
            title = None
            if title_fmt is not None:
                ql, qm, qh = _quantile(x, [0.16, 0.5, 0.84], weights=weights)
                q_minus, q_plus = qm - ql, qh - qm
                fmt = "{{0:{0}}}".format(title_fmt).format
                title = r"${{{0}}}_{{-{1}}}^{{+{2}}}$"
                title = title.format(fmt(qm), fmt(q_minus), fmt(q_plus))
                title = "{0} = {1}".format(label, title)
                ax.set_title(title, **title_kwargs)

    return fig, axes


def cornerpoints(results, bounds=None, cmap='plasma', color=None,
                 plot_kwargs=None, labels=None, label_kwargs=None,
                 truths=None, truth_color='red', truth_kwargs=None,
                 max_n_ticks=5, use_math_text=False, fig=None):
    """
    Generate a (sub-)corner plot of 2-D sample projections.


    Parameters
    ----------
    results : `Results` dictionary instance
        A results instance output by `dynesty` (or generated by the user).

    bounds : iterable with shape (ndim,), optional
        A list where each element is either a length 2 tuple containing
        lower and upper bounds or a float in range (0., 1.] giving the
        fraction of (weighted) samples to include. If a fraction is provided,
        the bounds are chosen to be equal-tailed. An example would be
        [(0., 10.), 0.95, (5., 6.)]. Default is *0.999999426697*
        (5-sigma credible interval).

    cmap : str, optional
        A `~matplotlib` style colormap used when plotting the points,
        where each point is colored according to its weight. Default is
        'plasma'.

    color : str, optional
        A `~matplotlib` style color used when plotting the points.
        This overrides the `cmap` option by giving all points
        the same color. Default is *None*.

    plot_kwargs : dict, optional
        Extra keyword arguments that will be used for plotting the points.

    labels : iterable with shape (ndim,), optional
        A list of names for each parameter. If not provided, the default name
        used when plotting is `x_i`.

    label_kwargs : dict, optional
        Extra keyword arguments that will be sent to the `set_xlabel` and
        `set_ylabel` methods.

    truths : iterable with shape (ndim,), optional
        A list of reference values that will be overplotted on the traces and
        marginalized 1-D posteriors as solid horizontal/vertical lines.
        Individual values can be exempt using `None`. Default is *None*.

    truth_color : str or iterable with shape (ndim,), optional
        A `~matplotlib` style color (either a single color or a different
        value for each subplot) used when plotting `truths`. Default is 'red'.

    truth_kwargs : dict, optional
        Extra keyword arguments that will be used for plotting the vertical
        and horizontal lines with `truths`.

    max_n_ticks : int, optional
        Maximum number of ticks allowed. Default is *5*.

    use_math_text : bool, optional
        Whether the axis tick labels for very large/small exponents should be
        displayed as powers of 10 rather than using `e`. Default is *False*.

    fig : `~matplotlib.Figure`, optional
        If provided, overplot the traces and marginalized 1-D posteriors
        onto the provided figure object. Otherwise, by default an
        internal figure is generated.


    Returns
    -------
    cornerpoints : `~matplotlib.Figure`
        Output (sub-)corner plot of samples.

    """

    if truth_kwargs is None:
        truth_kwargs = dict()
    if label_kwargs is None:
        label_kwargs = dict()
    if plot_kwargs is None:
        plot_kwargs = dict()

    # Extract weighted samples.
    samples = results['samples']
    try:
        weights = np.exp(results['logwt'])
    except:
        weights = results['weights']

    # Deal with 1D results. A number of extra catches are also here
    # in case users are trying to plot other results besides the `Results`
    # instance generated by `dynesty`.
    samples = np.atleast_1d(samples)
    if len(samples.shape) == 1:
        samples = np.atleast_2d(samples)
    else:
        assert len(samples.shape) == 2, "Samples must be 1- or 2-D."
        samples = samples.T
    assert samples.shape[0] <= samples.shape[1], "There are more " \
                                                 "dimensions than samples!"
    ndim, nsamps = samples.shape

    # Check weights.
    if weights.ndim != 1:
        raise ValueError("Weights must be 1-D.")
    if nsamps != weights.shape[0]:
        raise ValueError("The number of weights and samples disagree!")

    # Determine plotting bounds.
    if bounds is None:
        bounds = [0.999999426697 for i in range(ndim)]
    bounds = list(bounds)
    if len(bounds) != ndim:
        raise ValueError("Dimension mismatch between samples and bounds.")
    for i, _ in enumerate(bounds):
        try:
            xmin, xmax = bounds[i]
        except:
            q = [0.5 - 0.5 * bounds[i], 0.5 + 0.5 * bounds[i]]
            bounds[i] = _quantile(samples[i], q, weights=weights)

    # Set labels
    if labels is None:
        labels = [r"$x_{0}$".format(i) for i in range(ndim)]

    # Set colormap.
    if color is None:
        color = weights

    # Setup axis layout (from `corner.py`).
    factor = 2.0  # size of side of one panel
    lbdim = 0.5 * factor  # size of left/bottom margin
    trdim = 0.2 * factor  # size of top/right margin
    whspace = 0.05  # size of width/height margin
    plotdim = factor * (ndim - 1.) + factor * (ndim - 2.) * whspace
    dim = lbdim + plotdim + trdim  # total size

    # Initialize figure.
    if fig is None:
        fig, axes = pl.subplots(ndim - 1, ndim - 1, figsize=(dim, dim))
    else:
        try:
            fig, axes = fig
            axes = np.array(axes).reshape((ndim - 1, ndim - 1))
        except:
            raise ValueError("Mismatch between axes and dimension.")

    # Format figure.
    lb = lbdim / dim
    tr = (lbdim + plotdim) / dim
    fig.subplots_adjust(left=lb, bottom=lb, right=tr, top=tr,
                        wspace=whspace, hspace=whspace)

    # Plot the 2-D projected samples.
    for i, x in enumerate(samples[1:]):
        for j, y in enumerate(samples[:-1]):
            ax = axes[i, j]
            # Setup axes.
            if j > i:
                ax.set_frame_on(False)
                ax.set_xticks([])
                ax.set_yticks([])
                continue
            if max_n_ticks == 0:
                ax.xaxis.set_major_locator(NullLocator())
                ax.yaxis.set_major_locator(NullLocator())
            else:
                ax.xaxis.set_major_locator(MaxNLocator(max_n_ticks,
                                                       prune="lower"))
                ax.yaxis.set_major_locator(MaxNLocator(max_n_ticks,
                                                       prune="lower"))
            # Label axes.
            sf = ScalarFormatter(useMathText=use_math_text)
            ax.xaxis.set_major_formatter(sf)
            ax.yaxis.set_major_formatter(sf)
            if i < ndim - 2:
                ax.set_xticklabels([])
            else:
                [l.set_rotation(45) for l in ax.get_xticklabels()]
                ax.set_xlabel(labels[j], **label_kwargs)
                ax.xaxis.set_label_coords(0.5, -0.3)
            if j > 0:
                ax.set_yticklabels([])
            else:
                [l.set_rotation(45) for l in ax.get_yticklabels()]
                ax.set_ylabel(labels[i+1], **label_kwargs)
                ax.yaxis.set_label_coords(-0.3, 0.5)
            # Plot distribution.
            ax.scatter(y, x, c=color, s=1, cmap=cmap,
                       **plot_kwargs)
            # Add truth values
            if truths is not None:
                if truths[j] is not None:
                    try:
                        [ax.axvline(t, color=truth_color, ls="solid",
                                    **truth_kwargs) for t in truths[j]]
                    except:
                        ax.axvline(truths[j], color=truth_color, ls="solid",
                                   **truth_kwargs)
                if truths[i+1] is not None:
                    try:
                        [ax.axhline(t, color=truth_color, ls="solid",
                                    **truth_kwargs) for t in truths[i+1]]
                    except:
                        ax.axhline(truths[i+1], color=truth_color, ls="solid",
                                   **truth_kwargs)

    return (fig, axes)


def cornerplot(results, bounds=None, quantiles=[0.16, 0.5, 0.84],
               color='black', smooth=0.02, hist_kwargs=None,
               hist2d_kwargs=None, labels=None, label_kwargs=None,
               show_titles=False, title_fmt=".2f", title_kwargs=None,
               truths=None, truth_color='red', truth_kwargs=None,
               max_n_ticks=5, top_ticks=False, use_math_text=False,
               verbose=False, fig=None):
    """
    Generate a corner plot of the 1-D and 2-D marginalized posteriors.


    Parameters
    ----------
    results : `Results` dictionary instance
        A results instance output by `dynesty` (or generated by the user).

    bins : int or iterable with shape (ndim,)
        The number of bins to use (either a single value or a different value
        for each parameter) when plotting the 1-D and 2-D histograms.

    bounds : iterable with shape (ndim,), optional
        A list where each element is either a length 2 tuple containing
        lower and upper bounds or a float in range (0., 1.] giving the
        fraction of (weighted) samples to include. If a fraction is provided,
        the bounds are chosen to be equal-tailed. An example would be
        [(0., 10.), 0.95, (5., 6.)]. Default is *0.999999426697*
        (5-sigma credible interval).

    quantiles : iterable, optional
        A list of fractional quantiles to overplot on the 1-D marginalized
        posteriors as vertical dashed lines. Default is *[0.16, 0.5, 0.84]*
        (spanning the 68%/1-sigma credible interval).

    color : str or iterable with shape (ndim,), optional
        A `~matplotlib` style color (either a single color or a different
        value for each subplot) used when plotting the histograms.
        Default is 'black'.

    smooth : float or iterable with shape (ndim,), optional
        The standard deviation (either a single value or a different value for
        each subplot) for the Gaussian kernel used to smooth the 1-D and 2-D
        marginalized posteriors, expressed as a fraction of the bounds.
        Default is *0.02* (2% smoothing). If an integer is provided instead,
        this will instead default to a simple (weighted) histogram with
        `bins=smooth`.

    hist_kwargs : dict, optional
        Extra keyword arguments to send to the 1-D (smoothed) histograms.

    hist2d_kwargs : dict, optional
        Extra keyword arguments to send to the 2-D (smoothed) histograms.

    labels : iterable with shape (ndim,), optional
        A list of names for each parameter. If not provided, the default name
        used when plotting is `x_i`.

    label_kwargs : dict, optional
        Extra keyword arguments that will be sent to the `set_xlabel` and
        `set_ylabel` methods.

    show_titles : bool, optional
        Whether to display a title above each 1-D marginalized posterior
        showing the 0.5 quantile along with the upper/lower bounds associated
        with the 0.16 and 0.84 (68%/1-sigma credible interval) quantiles.
        Default is *True*.

    title_fmt : str, optional
        The format string for the quantiles provided in the title. Default is
        ".2f".

    title_kwargs : dict, optional
        Extra keyword arguments that will be sent to the `set_title` command.

    truths : iterable with shape (ndim,), optional
        A list of reference values that will be overplotted on the traces and
        marginalized 1-D posteriors as solid horizontal/vertical lines.
        Individual values can be exempt using `None`. Default is *None*.

    truth_color : str or iterable with shape (ndim,), optional
        A `~matplotlib` style color (either a single color or a different
        value for each subplot) used when plotting `truths`. Default is 'red'.

    truth_kwargs : dict, optional
        Extra keyword arguments that will be used for plotting the vertical
        and horizontal lines with `truths`.

    max_n_ticks : int, optional
        Maximum number of ticks allowed. Default is *5*.

    top_ticks : bool, optional
        Whether to label the top (rather than bottom) ticks. Default is
        *False*.

    use_math_text : bool, optional
        Whether the axis tick labels for very large/small exponents should be
        displayed as powers of 10 rather than using `e`. Default is *False*.

    verbose : bool, optional
        Whether to print the values of the computed quantiles associated with
        each parameter. Default is *False*.

    fig : `~matplotlib.Figure`, optional
        If provided, overplot the traces and marginalized 1-D posteriors
        onto the provided figure object. Otherwise, by default an
        internal figure is generated.


    Returns
    -------
    cornerplot : `~matplotlib.Figure`
        Output corner plot.

    """

    if quantiles is None:
        quantiles = []
    if truth_kwargs is None:
        truth_kwargs = dict()
    if label_kwargs is None:
        label_kwargs = dict()
    if title_kwargs is None:
        title_kwargs = dict()
    if hist_kwargs is None:
        hist_kwargs = dict()
    hist_kwargs['alpha'] = hist_kwargs.get('alpha', 0.6)
    if hist2d_kwargs is None:
        hist2d_kwargs = dict()
    hist2d_kwargs['alpha'] = hist2d_kwargs.get('alpha', 0.6)

    # Extract weighted samples.
    samples = results['samples']
    try:
        weights = np.exp(results['logwt'])
    except:
        weights = results['weights']

    # Deal with 1D results. A number of extra catches are also here
    # in case users are trying to plot other results besides the `Results`
    # instance generated by `dynesty`.
    samples = np.atleast_1d(samples)
    if len(samples.shape) == 1:
        samples = np.atleast_2d(samples)
    else:
        assert len(samples.shape) == 2, "Samples must be 1- or 2-D."
        samples = samples.T
    assert samples.shape[0] <= samples.shape[1], "There are more " \
                                                 "dimensions than samples!"
    ndim, nsamps = samples.shape

    # Check weights.
    if weights.ndim != 1:
        raise ValueError("Weights must be 1-D.")
    if nsamps != weights.shape[0]:
        raise ValueError("The number of weights and samples disagree!")

    # Determine plotting bounds.
    if bounds is None:
        bounds = [0.999999426697 for i in range(ndim)]
    bounds = list(bounds)
    if len(bounds) != ndim:
        raise ValueError("Dimension mismatch between samples and bounds.")
    for i, _ in enumerate(bounds):
        try:
            xmin, xmax = bounds[i]
        except:
            q = [0.5 - 0.5 * bounds[i], 0.5 + 0.5 * bounds[i]]
            bounds[i] = _quantile(samples[i], q, weights=weights)

    # Set labels
    if labels is None:
        labels = [r"$x_{0}$".format(i) for i in range(ndim)]

    # Setting up smoothing.
    if (isinstance(smooth, types.IntType) or isinstance(smooth,
                                                        types.FloatType)):
        smooth = [smooth for i in range(ndim)]

    # Setup axis layout (from `corner.py`).
    factor = 2.0  # size of side of one panel
    lbdim = 0.5 * factor  # size of left/bottom margin
    trdim = 0.2 * factor  # size of top/right margin
    whspace = 0.05  # size of width/height margin
    plotdim = factor * ndim + factor * (ndim - 1.) * whspace  # plot size
    dim = lbdim + plotdim + trdim  # total size

    # Initialize figure.
    if fig is None:
        fig, axes = pl.subplots(ndim, ndim, figsize=(dim, dim))
    else:
        try:
            fig, axes = fig
            axes = np.array(axes).reshape((ndim, ndim))
        except:
            raise ValueError("Mismatch between axes and dimension.")

    # Format figure.
    lb = lbdim / dim
    tr = (lbdim + plotdim) / dim
    fig.subplots_adjust(left=lb, bottom=lb, right=tr, top=tr,
                        wspace=whspace, hspace=whspace)

    # Plotting.
    for i, x in enumerate(samples):
        if np.shape(samples)[0] == 1:
            ax = axes
        else:
            ax = axes[i, i]

        # Plot the 1-D marginalized posteriors.

        # Setup axes
        ax.set_xlim(bounds[i])
        if max_n_ticks == 0:
            ax.xaxis.set_major_locator(NullLocator())
            ax.yaxis.set_major_locator(NullLocator())
        else:
            ax.xaxis.set_major_locator(MaxNLocator(max_n_ticks,
                                                   prune="lower"))
            ax.yaxis.set_major_locator(NullLocator())
        # Label axes.
        sf = ScalarFormatter(useMathText=use_math_text)
        ax.xaxis.set_major_formatter(sf)
        if i < ndim - 1:
            if top_ticks:
                ax.xaxis.set_ticks_position("top")
                [l.set_rotation(45) for l in ax.get_xticklabels()]
            else:
                ax.set_xticklabels([])
        else:
            [l.set_rotation(45) for l in ax.get_xticklabels()]
            ax.set_xlabel(labels[i], **label_kwargs)
            ax.xaxis.set_label_coords(0.5, -0.3)
        # Generate distribution.
        sx = smooth[i]
        if isinstance(smooth, types.IntType):
            # If `sx` is an integer, plot a weighted histogram with
            # `sx` bins within the provided bounds.
            n, b, _ = ax.hist(x, bins=sx, weights=weights, color=color,
                              range=np.sort(bounds[i]), **hist_kwargs)
        else:
            if norm_kde is None:
                raise ImportError("Please install scipy if you would like "
                                  "to use Gaussian smoothing.")
            else:
                # If `sx` is a float, oversample the data relative to the
                # smoothing filter by a factor of 5, then use a Gaussian
                # filter to smooth the results.
                bins = int(round(5. / sx))
                n, b = np.histogram(x, bins=bins, weights=weights,
                                    range=np.sort(bounds[i]))
                n = norm_kde(n, 5.)
                b0 = 0.5 * (b[1:] + b[:-1])
                n, b, _ = ax.hist(b0, bins=b, weights=n,
                                  range=np.sort(bounds[i]), color=color,
                                  **hist_kwargs)
        ax.set_ylim([0., max(n) * 1.05])
        # Plot quantiles.
        if quantiles is not None and len(quantiles) > 0:
            qs = _quantile(x, quantiles, weights=weights)
            for q in qs:
                ax.axvline(q, lw=2, ls="dashed", color=color)
            if verbose:
                print("Quantiles:")
                print(label, [blob for blob in zip(quantiles, qs)])
        # Add truth value(s).
        if truths is not None and truths[i] is not None:
            try:
                [ax.axvline(t, color=truth_color, ls="solid",
                            **truth_kwargs) for t in truths[i]]
            except:
                ax.axvline(truths[i], color=truth_color, ls="solid",
                           **truth_kwargs)
        # Set titles.
        if show_titles:
            title = None
            if title_fmt is not None:
                ql, qm, qh = _quantile(x, [0.16, 0.5, 0.84], weights=weights)
                q_minus, q_plus = qm - ql, qh - qm
                fmt = "{{0:{0}}}".format(title_fmt).format
                title = r"${{{0}}}_{{-{1}}}^{{+{2}}}$"
                title = title.format(fmt(qm), fmt(q_minus), fmt(q_plus))
                title = "{0} = {1}".format(labels[i], title)
                ax.set_title(title, **title_kwargs)

        for j, y in enumerate(samples):
            if np.shape(samples)[0] == 1:
                ax = axes
            else:
                ax = axes[i, j]

            # Plot the 2-D marginalized posteriors.

            # Setup axes.
            if j > i:
                ax.set_frame_on(False)
                ax.set_xticks([])
                ax.set_yticks([])
                continue
            elif j == i:
                continue

            if max_n_ticks == 0:
                ax.xaxis.set_major_locator(NullLocator())
                ax.yaxis.set_major_locator(NullLocator())
            else:
                ax.xaxis.set_major_locator(MaxNLocator(max_n_ticks,
                                                       prune="lower"))
                ax.yaxis.set_major_locator(MaxNLocator(max_n_ticks,
                                                       prune="lower"))
            # Label axes.
            sf = ScalarFormatter(useMathText=use_math_text)
            ax.xaxis.set_major_formatter(sf)
            ax.yaxis.set_major_formatter(sf)
            if i < ndim - 1:
                ax.set_xticklabels([])
            else:
                [l.set_rotation(45) for l in ax.get_xticklabels()]
                ax.set_xlabel(labels[j], **label_kwargs)
                ax.xaxis.set_label_coords(0.5, -0.3)
            if j > 0:
                ax.set_yticklabels([])
            else:
                [l.set_rotation(45) for l in ax.get_yticklabels()]
                ax.set_ylabel(labels[i], **label_kwargs)
                ax.yaxis.set_label_coords(-0.3, 0.5)
            # Generate distribution.
            sy = smooth[j]
            _hist2d(y, x, ax=ax, bounds=[bounds[j], bounds[i]],
                    weights=weights, color=color, smooth=[sy, sx],
                    **hist2d_kwargs)
            # Add truth values
            if truths is not None:
                if truths[j] is not None:
                    try:
                        [ax.axvline(t, color=truth_color, ls="solid",
                                    **truth_kwargs) for t in truths[j]]
                    except:
                        ax.axvline(truths[j], color=truth_color, ls="solid",
                                   **truth_kwargs)
                if truths[i] is not None:
                    try:
                        [ax.axhline(t, color=truth_color, ls="solid",
                                    **truth_kwargs) for t in truths[i]]
                    except:
                        ax.axhline(truths[i], color=truth_color, ls="solid",
                                   **truth_kwargs)

    return (fig, axes)


def proposal(results, dims, it=None, idx=None, prior_transform=None,
             ndraws=5000, color='gray', plot_kwargs=None, labels=None,
             label_kwargs=None, max_n_ticks=5, use_math_text=False,
             show_live=False, live_color='red', live_kwargs=None,
             fig=None):
    """
    Return the proposal distribution used to propose (1) live points
    at a given iteration or (2) a specific dead point during
    the course of a run, projected onto the 2-D dimensions specified
    by `dims`. If `prior_transform` is provided, the proposal
    distribution is plotted in the native model space.


    Parameters
    ----------
    results : `Results` dictionary instance
        A results instance output by `dynesty` (or generated by the user).

    dims : tuple of length 2
        The dimensions used to plot the proposal.

    it : int, optional
        If provided, returns the proposal distribution at the specified
        iteration of the nested sampling run. Note that this option and `idx`
        are mutually exclusive.

    idx : int, optional
        If provided, returns the proposal distribution used to propose the
        dead point at the specified iteration of the nested sampling run. Note
        that this option and `it` are mutually exclusive.

    prior_transform : func, optional
        The function transforming samples on the unit cube back to samples
        in the native model space. If provided, the transformed proposal
        distribution will also be plotted.

    ndraws : int, optional
        The number of random samples to draw from the proposal distribution
        when plotting. Default is *5000*.

    color : str, optional
        The color of the points randomly sampled from the proposal
        distribution. Default is 'gray'.

    plot_kwargs : dict, optional
        Extra keyword arguments used when plotting the proposal draws.

    labels : iterable with shape (ndim,), optional
        A list of names for each parameter. If not provided, the default name
        used when plotting is `x_i`.

    label_kwargs : dict, optional
        Extra keyword arguments that will be sent to the `set_xlabel` and
        `set_ylabel` methods.

    max_n_ticks : int, optional
        Maximum number of ticks allowed. Default is *5*.

    use_math_text : bool, optional
        Whether the axis tick labels for very large/small exponents should be
        displayed as powers of 10 rather than using `e`. Default is *False*.

    show_live : bool, optional
        Whether the live points at a given iteration (for `it`) or
        associated with the proposal (for `idx`) should be highlighted.
        Default is *False*.

    live_color : str, optional
        The color of the live points. Default is 'red'.

    live_kwargs : dict, optional
        Extra keyword arguments used when plotting the live points.

    fig : `~matplotlib.Figure`, optional
        If provided, overplot the draws onto the provided figure object.
        Otherwise, by default an internal figure is generated.


    Returns
    -------
    proposal_plot : `~matplotlib.Figure`
        Output plot of the proposal distribution.

    """

    if plot_kwargs is None:
        plot_kwargs = dict()
    if label_kwargs is None:
        label_kwargs = dict()
    if live_kwargs is None:
        live_kwargs = dict()

    if (it is None and idx is None) or (it is not None and idx is not None):
        raise ValueError("You must specify either an iteration or an index!")

    # Extract proposals.
    try:
        proposals = results['prop']
    except:
        raise ValueError("No proposals were saved in the results!")
    nprop = len(proposals)
    niter = results['niter']
    nsamps = len(results['samples'])
    nlive = results['nlive']

    if it is not None:
        if it >= niter:
            raise ValueError("The iteration requested goes beyond the "
                             "number of iterations in the run.")
        # Extract proposal iterations.
        try:
            prop_iter = np.array(results['prop_iter'])
        except:
            raise ValueError("Cannot reconstruct the proposal used at the "
                             "specified iteration since proposal "
                             "iterations were not saved in the results.")

        # Find proposal at the specified iteration.
        if it == 0:
            pidx = 0
        else:
            pidx = prop_iter[it]
    else:
        if idx >= nsamps:
            raise ValueError("The index requested goes beyond the "
                             "number of samples in the run.")
        try:
            samples_prop = results['samples_prop']
        except:
            raise ValueError("Cannot reconstruct the proposal used to "
                             "compute the specified dead point since "
                             "sample proposal indices were not saved "
                             "in the results.")
        # Grab relevant proposal.
        pidx = samples_prop[idx]

    # Get desired proposal.
    prop = proposals[pidx]

    # Do we want to show the live points at the specified iteration?
    # If so, we need to rewind our proposal to check.
    # (We could also go forward; this is an arbitrary choice.)
    if show_live:
        # We can only reconstruct the run if the final set of
        # live points were added to the results.
        if nsamps - niter != nlive:
            raise ValueError("Cannot reconstruct proposal because the "
                             "final set of live points are not included in "
                             "the results.")
        # Grab our final set of live points (with proper IDs).
        samples = results['samples_u']
        samples_id = results['samples_id']
        ndim = samples.shape[1]
        live_u = np.empty((nlive, ndim))
        live_u[samples_id[-nlive:]] = samples[-nlive:]
        # Run our sampling backwards.
        if it is None:
            it = results['samples_it'][idx]
        # Run until we hit the target iteration.
        for i in range(1, niter - it + 1):
            r = -(nlive + i)
            uidx = samples_id[r]
            live_u[uidx] = samples[r]

    # Draw samples from the proposal.
    try:
        # If proposal is "fixed", go ahead and draw samples from it.
        psamps = prop.samples(ndraws)
    except:
        # If proposal is based on the distribution of live points at a
        # specific iteration, we need to reconstruct what those were.
        if not show_live:
            # Only reconstruct the run if we haven't done it already.
            if nsamps - niter != nlive:
                raise ValueError("Cannot reconstruct proposal because the "
                                 "final set of live points are not included "
                                 "in the results.")
            # Grab our final set of live points (with proper IDs).
            samples = results['samples_u']
            samples_id = results['samples_id']
            ndim = samples.shape[1]
            live_u = np.empty((nlive, ndim))
            live_u[samples_id[-nlive:]] = samples[-nlive:]
            # Run our sampling backwards.
            if it is None:
                it = results['samples_it'][idx]
            for i in range(1, niter - it + 1):
                r = -(nlive + i)
                uidx = samples_id[r]
                live_u[uidx] = samples[r]
        psamps = prop.samples(ndraws, live_u)

    # Projecting samples to input dimensions and possibly
    # the native model space.
    if prior_transform is None:
        x1, x2 = psamps[:, dims].T
        if show_live:
            l1, l2 = live_u[:, dims].T
    else:
        # Remove points outside of the unit cube.
        sel = [np.all(point > 0.) and np.all(point < 1.)
               for point in psamps]
        vsamps = np.array(map(prior_transform, psamps[sel]))
        x1, x2 = vsamps[:, dims].T
        if show_live:
            lsamps = np.array(map(prior_transform, live_u))
            l1, l2 = lsamps[:, dims].T

    # Setting up default plot layout.
    if fig is None:
        fig, axes = pl.subplots(1, 1, figsize=(6, 6))
    else:
        fig, axes = fig
        try:
            axes.plot()
        except:
            raise ValueError("Provided axes do not match the required shape "
                             "for plotting samples.")

    # Plotting.
    axes.plot(x1, x2, '.', color=color, markersize=1, **plot_kwargs)
    if show_live:
        axes.plot(l1, l2, 'o', color=live_color, markersize=1, **live_kwargs)

    # Setup axes
    if max_n_ticks == 0:
        axes.xaxis.set_major_locator(NullLocator())
        axes.yaxis.set_major_locator(NullLocator())
    else:
        axes.xaxis.set_major_locator(MaxNLocator(max_n_ticks))
        axes.yaxis.set_major_locator(MaxNLocator(max_n_ticks))
    # Label axes.
    sf = ScalarFormatter(useMathText=use_math_text)
    axes.xaxis.set_major_formatter(sf)
    axes.yaxis.set_major_formatter(sf)
    if labels is not None:
        axes.set_xlabel(labels[0], **label_kwargs)
        axes.set_ylabel(label[1], **label_kwargs)
    else:
        axes.set_xlabel(r"$x_{0}$".format(dims[0]), **label_kwargs)
        axes.set_ylabel(r"$x_{0}$".format(dims[1]), **label_kwargs)

    return fig, axes


def cornerprop(results, it=None, idx=None, prior_transform=None,
               ndraws=5000, color='gray', plot_kwargs=None, labels=None,
               label_kwargs=None, max_n_ticks=5, use_math_text=False,
               show_live=False, live_color='red', live_kwargs=None,
               fig=None):
    """
    Return the proposal distribution used to propose (1) live points
    at a given iteration or (2) a specific dead point during
    the course of a run, projected onto all pairs of dimensions.
    If `prior_transform` is provided, the proposal distribution
    is plotted in the native model space.


    Parameters
    ----------
    results : `Results` dictionary instance
        A results instance output by `dynesty` (or generated by the user).

    dims : tuple of length 2
        The dimensions used to plot the proposal.

    it : int, optional
        If provided, returns the proposal distribution at the specified
        iteration of the nested sampling run. Note that this option and `idx`
        are mutually exclusive.

    idx : int, optional
        If provided, returns the proposal distribution used to propose the
        dead point at the specified iteration of the nested sampling run. Note
        that this option and `it` are mutually exclusive.

    prior_transform : func, optional
        The function transforming samples on the unit cube back to samples
        in the native model space. If provided, the transformed proposal
        distribution will also be plotted.

    ndraws : int, optional
        The number of random samples to draw from the proposal distribution
        when plotting. Default is *5000*.

    color : str, optional
        The color of the points randomly sampled from the proposal
        distribution. Default is 'gray'.

    plot_kwargs : dict, optional
        Extra keyword arguments used when plotting the proposal draws.

    labels : iterable with shape (ndim,), optional
        A list of names for each parameter. If not provided, the default name
        used when plotting is `x_i`.

    label_kwargs : dict, optional
        Extra keyword arguments that will be sent to the `set_xlabel` and
        `set_ylabel` methods.

    max_n_ticks : int, optional
        Maximum number of ticks allowed. Default is *5*.

    use_math_text : bool, optional
        Whether the axis tick labels for very large/small exponents should be
        displayed as powers of 10 rather than using `e`. Default is *False*.

    show_live : bool, optional
        Whether the live points at a given iteration (for `it`) or
        associated with the proposal (for `idx`) should be highlighted.
        Default is *False*.

    live_color : str, optional
        The color of the live points. Default is 'red'.

    live_kwargs : dict, optional
        Extra keyword arguments used when plotting the live points.

    fig : `~matplotlib.Figure`, optional
        If provided, overplot the draws onto the provided figure object.
        Otherwise, by default an internal figure is generated.


    Returns
    -------
    cornerprop : `~matplotlib.Figure`
        Output corner plot of the proposal distribution.

    """

    if label_kwargs is None:
        label_kwargs = dict()
    if plot_kwargs is None:
        plot_kwargs = dict()
    if live_kwargs is None:
        live_kwargs = dict()

    if (it is None and idx is None) or (it is not None and idx is not None):
        raise ValueError("You must specify either an iteration or an index!")

    # Extract proposals.
    try:
        proposals = results['prop']
    except:
        raise ValueError("No proposals were saved in the results!")
    nprop = len(proposals)
    niter = results['niter']
    nsamps = len(results['samples'])
    nlive = results['nlive']

    if it is not None:
        if it >= niter:
            raise ValueError("The iteration requested goes beyond the "
                             "number of iterations in the run.")
        # Extract proposal iterations.
        try:
            prop_iter = np.array(results['prop_iter'])
        except:
            raise ValueError("Cannot reconstruct the proposal used at the "
                             "specified iteration since proposal "
                             "iterations were not saved in the results.")

        # Find proposal at the specified iteration.
        if it == 0:
            pidx = 0
        else:
            pidx = prop_iter[it]
    else:
        if idx >= nsamps:
            raise ValueError("The index requested goes beyond the "
                             "number of samples in the run.")
        try:
            samples_prop = results['samples_prop']
        except:
            raise ValueError("Cannot reconstruct the proposal used to "
                             "compute the specified dead point since "
                             "sample proposal indices were not saved "
                             "in the results.")
        # Grab relevant proposal.
        pidx = samples_prop[idx]

    # Get desired proposal.
    prop = proposals[pidx]

    # Do we want to show the live points at the specified iteration?
    # If so, we need to rewind our proposal to check.
    # (We could also go forward; this is an arbitrary choice.)
    if show_live:
        # We can only reconstruct the run if the final set of
        # live points were added to the results.
        if nsamps - niter != nlive:
            raise ValueError("Cannot reconstruct proposal because the "
                             "final set of live points are not included in "
                             "the results.")
        # Grab our final set of live points (with proper IDs).
        samples = results['samples_u']
        samples_id = results['samples_id']
        ndim = samples.shape[1]
        live_u = np.empty((nlive, ndim))
        live_u[samples_id[-nlive:]] = samples[-nlive:]
        # Run our sampling backwards.
        if it is None:
            it = results['samples_it'][idx]
        # Run until we hit the target iteration.
        for i in range(1, niter - it + 1):
            r = -(nlive + i)
            uidx = samples_id[r]
            live_u[uidx] = samples[r]

    # Draw samples from the proposal.
    try:
        # If proposal is "fixed", go ahead and draw samples from it.
        psamps = prop.samples(ndraws)
    except:
        # If proposal is based on the distribution of live points at a
        # specific iteration, we need to reconstruct what those were.
        if not show_live:
            # Only reconstruct the run if we haven't done it already.
            if nsamps - niter != nlive:
                raise ValueError("Cannot reconstruct proposal because the "
                                 "final set of live points are not included "
                                 "in the results.")
            # Grab our final set of live points (with proper IDs).
            samples = results['samples_u']
            samples_id = results['samples_id']
            ndim = samples.shape[1]
            live_u = np.empty((nlive, ndim))
            live_u[samples_id[-nlive:]] = samples[-nlive:]
            # Run our sampling backwards.
            if it is None:
                it = results['samples_it'][idx]
            for i in range(1, niter - it + 1):
                r = -(nlive + i)
                uidx = samples_id[r]
                live_u[uidx] = samples[r]
        psamps = prop.samples(ndraws, live_u)

    # Projecting samples to input dimensions and possibly
    # the native model space.
    if prior_transform is None:
        psamps = psamps.T
        if show_live:
            lsamps = live_u.T
    else:
        # Remove points outside of the unit cube.
        sel = [np.all(point > 0.) and np.all(point < 1.)
               for point in psamps]
        psamps = np.array(map(prior_transform, psamps[sel]))
        psamps = psamps.T
        if show_live:
            lsamps = np.array(map(prior_transform, live_u))
            lsamps = lsamps.T

    # Set labels
    if labels is None:
        labels = [r"$x_{0}$".format(i) for i in range(ndim)]

    # Setup axis layout (from `corner.py`).
    factor = 2.0  # size of side of one panel
    lbdim = 0.5 * factor  # size of left/bottom margin
    trdim = 0.2 * factor  # size of top/right margin
    whspace = 0.05  # size of width/height margin
    plotdim = factor * (ndim - 1.) + factor * (ndim - 2.) * whspace
    dim = lbdim + plotdim + trdim  # total size

    # Initialize figure.
    if fig is None:
        fig, axes = pl.subplots(ndim - 1, ndim - 1, figsize=(dim, dim))
    else:
        try:
            fig, axes = fig
            axes = np.array(axes).reshape((ndim - 1, ndim - 1))
        except:
            raise ValueError("Mismatch between axes and dimension.")

    # Format figure.
    lb = lbdim / dim
    tr = (lbdim + plotdim) / dim
    fig.subplots_adjust(left=lb, bottom=lb, right=tr, top=tr,
                        wspace=whspace, hspace=whspace)

    # Plot the 2-D projected samples.
    for i, x in enumerate(psamps[1:]):
        for j, y in enumerate(psamps[:-1]):
            ax = axes[i, j]
            # Setup axes.
            if j > i:
                ax.set_frame_on(False)
                ax.set_xticks([])
                ax.set_yticks([])
                continue
            if max_n_ticks == 0:
                ax.xaxis.set_major_locator(NullLocator())
                ax.yaxis.set_major_locator(NullLocator())
            else:
                ax.xaxis.set_major_locator(MaxNLocator(max_n_ticks,
                                                       prune="lower"))
                ax.yaxis.set_major_locator(MaxNLocator(max_n_ticks,
                                                       prune="lower"))
            # Label axes.
            sf = ScalarFormatter(useMathText=use_math_text)
            ax.xaxis.set_major_formatter(sf)
            ax.yaxis.set_major_formatter(sf)
            if i < ndim - 2:
                ax.set_xticklabels([])
            else:
                [l.set_rotation(45) for l in ax.get_xticklabels()]
                ax.set_xlabel(labels[j], **label_kwargs)
                ax.xaxis.set_label_coords(0.5, -0.3)
            if j > 0:
                ax.set_yticklabels([])
            else:
                [l.set_rotation(45) for l in ax.get_yticklabels()]
                ax.set_ylabel(labels[i+1], **label_kwargs)
                ax.yaxis.set_label_coords(-0.3, 0.5)
            # Plot distribution.
            ax.plot(y, x, '.', c=color, ms=1, **plot_kwargs)
            # Add live points.
            if show_live:
                ax.plot(lsamps[j], lsamps[i+1], 'o', c=live_color,
                        ms=1, **live_kwargs)

    return (fig, axes)


def _hist2d(x, y, smooth=0.02, bounds=None, weights=None, levels=None,
            ax=None, color='gray', plot_datapoints=True, plot_density=True,
            plot_contours=True, no_fill_contours=False, fill_contours=False,
            contour_kwargs=None, contourf_kwargs=None, data_kwargs=None,
            **kwargs):
    """
    Plot a 2-D histogram of samples. Called internally by `cornerplot`.


    Parameters
    ----------
    x : interable with shape (nsamps,)
       Sample positions in the first dimension.

    y : iterable with shape (nsamps,)
       Sample positions in the second dimension.

    bounds : iterable with shape (ndim,), optional
        A list where each element is either a length 2 tuple containing
        lower and upper bounds or a float in range (0., 1.] giving the
        fraction of (weighted) samples to include. If a fraction is provided,
        the bounds are chosen to be equal-tailed. An example would be
        [(0., 10.), 0.95, (5., 6.)]. Default is *0.999999426697*
        (5-sigma credible interval).

    weights : iterable with shape (nsamps,)
        Weights associated with the samples. Default is *None* (no weights).

    levels : iterable, optional
        The contour levels to draw. Default are `[0.5, 1, 1.5, 2]-sigma`.

    ax : matplotlib.Axes, optional
        An `axes` instance on which to add the 2-D histogram. If not provided,
        a figure will be generated.

    color : str, optional
        The color of the points randomly sampled from the proposal
        distribution. Default is 'gray'.

    plot_datapoints : bool, optional
        Whether to plot the individual data points. Default is *True*.

    plot_density : bool, optional
        Whether to draw the density colormap. Default is *True*.

    plot_contours : bool, optional
        Whether to draw the contours. Default is *True*.

    no_fill_contours : bool, optional
        Whether to add absolutely no filling to the contours. This differs
        from `fill_contours=False`, which still adds a white fill at the
        densest points. Default is *False*.

    fill_contours : bool, optional
        Whether to fill the contours. Default is *False*.

    contour_kwargs : dict
        Any additional keyword arguments to pass to the `contour` method.

    contourf_kwargs : dict
        Any additional keyword arguments to pass to the `contourf` method.

    data_kwargs : dict
        Any additional keyword arguments to pass to the `plot` method when
        adding the individual data points.

    """

    if ax is None:
        ax = pl.gca()

    # Determine plotting bounds.
    data = [x, y]
    if bounds is None:
        bounds = [0.999999426697 for i in range(2)]
    bounds = list(bounds)
    if len(bounds) != 2:
        raise ValueError("Dimension mismatch between samples and bounds.")
    for i, _ in enumerate(bounds):
        try:
            xmin, xmax = bounds[i]
        except:
            q = [0.5 - 0.5 * bounds[i], 0.5 + 0.5 * bounds[i]]
            bounds[i] = _quantile(data[i], q, weights=weights)

    # The default "sigma" contour levels.
    if levels is None:
        levels = 1.0 - np.exp(-0.5 * np.arange(0.5, 2.1, 0.5) ** 2)

    # Color map for the density plot, over-plotted to indicate the
    # density of the points near the center.
    density_cmap = LinearSegmentedColormap.from_list(
        "density_cmap", [color, (1, 1, 1, 0)])

    # Color map used to hide the points at the high density areas.
    white_cmap = LinearSegmentedColormap.from_list(
        "white_cmap", [(1, 1, 1), (1, 1, 1)], N=2)

    # This "color map" is the list of colors for the contour levels if the
    # contours are filled.
    rgba_color = colorConverter.to_rgba(color)
    contour_cmap = [list(rgba_color) for l in levels] + [rgba_color]
    for i, l in enumerate(levels):
        contour_cmap[i][-1] *= float(i) / (len(levels)+1)

    # Initialize smoothing.
    if (isinstance(smooth, types.IntType) or isinstance(smooth,
                                                        types.FloatType)):
        smooth = [smooth, smooth]
    bins = []
    svalues = []
    for s in smooth:
        if isinstance(s, types.IntType):
            # If `s` is an integer, the weighted histogram has
            # `s` bins within the provided bounds.
            bins.append(s)
            svalues.append(0.)
        else:
            if norm_kde is None:
                raise ImportError("Please install scipy if you would "
                                  "like to use Gaussian smoothing.")
            # If `s` is a float, oversample the data relative to the
            # smoothing filter by a factor of 5, then use a Gaussian
            # filter to smooth the results.
            bins.append(int(round(5. / s)))
            svalues.append(5.)

    # We'll make the 2D histogram to directly estimate the density.
    try:
        H, X, Y = np.histogram2d(x.flatten(), y.flatten(), bins=bins,
                                 range=list(map(np.sort, bounds)),
                                 weights=weights)
    except ValueError:
        raise ValueError("It looks like at least one of your sample columns "
                         "have no dynamic range.")

    # Smooth the results.
    if not np.all(svalues == 0.):
        H = norm_kde(H, svalues)

    # Compute the density levels.
    Hflat = H.flatten()
    inds = np.argsort(Hflat)[::-1]
    Hflat = Hflat[inds]
    sm = np.cumsum(Hflat)
    sm /= sm[-1]
    V = np.empty(len(levels))
    for i, v0 in enumerate(levels):
        try:
            V[i] = Hflat[sm <= v0][-1]
        except:
            V[i] = Hflat[0]
    V.sort()
    m = (np.diff(V) == 0)
    if np.any(m):
        logging.warning("Too few points to create valid contours.")
    while np.any(m):
        V[np.where(m)[0][0]] *= 1.0 - 1e-4
        m = (np.diff(V) == 0)
    V.sort()

    # Compute the bin centers.
    X1, Y1 = 0.5 * (X[1:] + X[:-1]), 0.5 * (Y[1:] + Y[:-1])

    # Extend the array for the sake of the contours at the plot edges.
    H2 = H.min() + np.zeros((H.shape[0] + 4, H.shape[1] + 4))
    H2[2:-2, 2:-2] = H
    H2[2:-2, 1] = H[:, 0]
    H2[2:-2, -2] = H[:, -1]
    H2[1, 2:-2] = H[0]
    H2[-2, 2:-2] = H[-1]
    H2[1, 1] = H[0, 0]
    H2[1, -2] = H[0, -1]
    H2[-2, 1] = H[-1, 0]
    H2[-2, -2] = H[-1, -1]
    X2 = np.concatenate([X1[0] + np.array([-2, -1]) * np.diff(X1[:2]), X1,
                         X1[-1] + np.array([1, 2]) * np.diff(X1[-2:])])
    Y2 = np.concatenate([Y1[0] + np.array([-2, -1]) * np.diff(Y1[:2]), Y1,
                         Y1[-1] + np.array([1, 2]) * np.diff(Y1[-2:])])

    # Plot the data points.
    if plot_datapoints:
        if data_kwargs is None:
            data_kwargs = dict()
        data_kwargs["color"] = data_kwargs.get("color", color)
        data_kwargs["ms"] = data_kwargs.get("ms", 2.0)
        data_kwargs["mec"] = data_kwargs.get("mec", "none")
        data_kwargs["alpha"] = data_kwargs.get("alpha", 0.1)
        ax.plot(x, y, "o", zorder=-1, rasterized=True, **data_kwargs)

    # Plot the base fill to hide the densest data points.
    if (plot_contours or plot_density) and not no_fill_contours:
        ax.contourf(X2, Y2, H2.T, [V.min(), H.max()],
                    cmap=white_cmap, antialiased=False)

    if plot_contours and fill_contours:
        if contourf_kwargs is None:
            contourf_kwargs = dict()
        contourf_kwargs["colors"] = contourf_kwargs.get("colors", contour_cmap)
        contourf_kwargs["antialiased"] = contourf_kwargs.get("antialiased",
                                                             False)
        ax.contourf(X2, Y2, H2.T, np.concatenate([[0], V, [H.max()*(1+1e-4)]]),
                    **contourf_kwargs)

    # Plot the density map. This can't be plotted at the same time as the
    # contour fills.
    elif plot_density:
        ax.pcolor(X, Y, H.max() - H.T, cmap=density_cmap)

    # Plot the contour edge colors.
    if plot_contours:
        if contour_kwargs is None:
            contour_kwargs = dict()
        contour_kwargs["colors"] = contour_kwargs.get("colors", color)
        ax.contour(X2, Y2, H2.T, V, **contour_kwargs)

    ax.set_xlim(bounds[0])
    ax.set_ylim(bounds[1])


def _quantile(x, q, weights=None):
    """
    Compute (weighted) sample quantiles. Called internally by `traceplot`
    and `cornerplot`.


    Parameters
    ----------
    x : `~numpy.ndarray` with shape (nsamps,)
        Input samples.

    q : `~numpy.ndarray` with shape (nquantiles,)
       The list of quantiles to compute from [0., 1.].

    weights : `~numpy.ndarray` with shape (nsamps,), optional
        The associated weight from each sample.

    Returns
    -------
    quantiles : `~numpy.ndarray` with shape (nquantiles,)
        The sample quantiles computed at quantiles `q`.

    """

    # Initial check.
    x = np.atleast_1d(x)
    q = np.atleast_1d(q)

    # Quantile check.
    if np.any(q < 0.0) or np.any(q > 1.0):
        raise ValueError("Quantiles must be between 0. and 1.")

    if weights is None:
        # If no weights provided, this simply calls `np.percentile`.
        return np.percentile(x, list(100.0 * q))
    else:
        # If weights are provided, compute the weighted quantiles.
        weights = np.atleast_1d(weights)
        if len(x) != len(weights):
            raise ValueError("Dimension mismatch: len(weights) != len(x).")
        idx = np.argsort(x)  # sort samples
        sw = weights[idx]  # sort weights
        cdf = np.cumsum(sw)[:-1]  # compute CDF
        cdf /= cdf[-1]  # normalize CDF
        cdf = np.append(0, cdf)  # ensure proper span
        quantiles = np.interp(q, cdf, x[idx]).tolist()
        return quantiles
